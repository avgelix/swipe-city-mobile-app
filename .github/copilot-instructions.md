# Copilot Instructions: Swipe City

## Project Overview
This is a **React SPA** (single-page application) that helps users discover where to move through a gamified, card-swiping experience. The project is **currently in active development** with Phase 1 (City Matching) completed.

**Current Status:** Phase 1 complete - City/country matching game is live and functional.

## Architecture Principles

### Tech Stack (See DECISIONS.md)
- **Frontend:** React + Tailwind CSS + Framer Motion
- **AI:** Google Gemini (gemini-2.0-flash) via Vercel serverless function
- **Maps:** Google Maps JavaScript API (background displays)
- **State:** React state + localStorage for persistence
- **Hosting:** Vercel (SPA with serverless API proxy)
- **Illustrations:** Open-source SVG illustrations from [ManyPixels Gallery](https://www.manypixels.co/gallery)

### Key Architectural Constraints
1. **Zero-cost MVP:** Must stay within free tiers (Gemini: 1500 req/day, Vercel free tier)
2. **No backend server:** Pure SPA architecture, serverless functions only for API key protection
3. **Client-side state:** localStorage for progress tracking (no database, privacy-first)
4. **Hardcoded questions (Phase 1):** 20 universal questions in `questions.js` (8 categories, binary Y/N + 8-direction multiple choice)
5. **Dynamic questions (Phase 2):** Neighborhood questions generated by Gemini based on matched city

## Core Game Mechanics

### Swipe Interaction Pattern
- **Binary questions (Y/N):** Left = No, Right = Yes
- **Multiple choice (8 options):** 8 directional swipes (↑ ↓ ← → ↖ ↗ ↙ ↘)
  - Use **spatial/geographic mapping** when logical (e.g., cities map to compass directions)
  - Use **vertical axis for intensity** (Up = More, Down = Less)
  - Document arbitrary mappings in code comments for consistency
- **Implementation:** Use Framer Motion's drag/gesture system for smooth 8-direction detection
- **Visual feedback:** Cards animate off-screen in swipe direction

### Game Flow States
1. **Questions Phase:** User swipes through 20 cards, answers saved to localStorage
2. **AI Matching Phase:** Send answers to Vercel function → Gemini generates city match + explanation
3. **Results Phase:** Display match with explanation; user accepts → Phase 2, or refuses → collect feedback → restart
4. **Neighborhood Phase:** Gemini generates city-specific neighborhood questions based on matched location (e.g., Tokyo: "Prefer Shibuya vs Asakusa?", NYC: "Manhattan vs Brooklyn?")

### Progress Persistence
```javascript
// Store answers in localStorage after each swipe:
localStorage.setItem('gameProgress', JSON.stringify({
  currentQuestion: 5,
  answers: [/* array of user answers */],
  timestamp: Date.now()
}));
```

## Design System

### Visual Identity
- **Primary color:** Zillow blue `#0074E4`
- **Design inspiration:** "Zillow meets Tinder" - professional real estate aesthetic with playful game mechanics
- **Mobile-first design:** Optimized for 375x812 screen size (iPhone X/11/12/13 mini)
- **Responsive scaling:** All elements scale proportionally at larger screen sizes
- **Typography & spacing:** Use Tailwind's default scale, emphasize card-based layouts
- **Typography:** Asul font for question text and overlays (Google Fonts)
- **Card design:** White cards with stacked shadow effect, rounded corners, contextual SVG illustrations
- **Arrows:** Thin gray directional arrows that fade out during swipes
- **Background:** Google Maps showing random cities, updates after each question
- **Illustrations:** Custom SVG illustrations from ManyPixels Gallery stored in `src/assets/illustrations/`
  - 20 unique illustrations (Q1-snow.svg through Q20-late.svg)
  - Rendered as `<img>` tags with `object-contain` and `maxHeight: 320px`
  - Proper padding to prevent edge cutoff

### Tone & Voice
- **Character:** Helpful real estate agent narrator (slightly playful, not overly serious)
- **Copy style:** "Choose your own adventure" guidance, informative yet lighthearted
- **Example:** "Let's find your perfect city! Swipe right if you love vibrant nightlife..."

## Development Workflow

### Development Tools & Environment

**Primary Development Environment:**
- **GitHub Codespaces:** Cloud-based development environment (currently active)
- **GitHub Copilot:** AI pair programming assistant for code generation and completion

**Design Tools:**
- **Figma:** Primary design tool for mockups and visual design iteration
- **Lovable (AI Design Tool):** Optional tool for AI-generated UI components
  - Connected directly to GitHub repository
  - Pushes changes directly to `main` branch
  - Use for rapid UI prototyping and iteration

**Deployment:**
- **Vercel:** Automatic deployment on every push to `main`
  - Zero-config deployment for React + serverless functions
  - Environment variables managed in Vercel dashboard
  - Every commit triggers a new deployment (be mindful of broken builds)

**Integration Flow:**
```
Design (Figma/Lovable) → GitHub Push → Vercel Auto-Deploy
```

### Design System Approach

When working with Lovable-generated code:
1. **Accept UI layouts and component structure** (saves scaffolding time)
2. **Refactor styling to Tailwind** if Lovable uses inline styles or other CSS approaches
3. **Verify architectural constraints** (localStorage, no backend, serverless functions)
4. **Tailwind is the source of truth** for all styling decisions

### GitHub Copilot Usage for This Project

**Common tasks and suggested prompts:**

1. **Swipe Card Component:**
   - "Generate a Framer Motion swipe card component with 8-direction gesture detection using Math.atan2 for angle calculation"
   - "Create a React card component that animates off-screen based on swipe direction (8 directions)"

2. **State Management:**
   - "Create a custom React hook for managing game progress in localStorage with currentQuestion and answers array"
   - "Build a hook that persists state to localStorage and loads on mount with error handling"

3. **Vercel Serverless Function:**
   - "Create a Vercel serverless function that proxies Google Gemini API calls keeping the API key secure"
   - "Build an API route that accepts user answers as JSON and returns city match from Gemini"

4. **Google Maps Integration:**
   - "Create a React component that displays Google Maps background and updates center on prop change"
   - "Build a Maps component that cycles through random cities array without reloading unnecessarily"

**Best Practices:**
- Prompt Copilot to use Tailwind utility classes (not inline styles or CSS modules)
- Emphasize zero-cost constraints when asking for library suggestions
- Request mobile-first responsive implementations (optimize for 375x812, scale proportionally)
- Ask for error boundaries and loading states
- Always use Asul font for card text (`fontFamily: 'Asul, sans-serif'`)
- Ensure illustrations maintain aspect ratio and don't get cut off at edges

### Project Setup (First Implementation)
```bash
# Use Vite for React setup (fast, modern, Vercel-compatible)
npm create vite@latest . -- --template react
npm install tailwindcss framer-motion @google/generative-ai
npx tailwindcss init
```

### Vercel Serverless Function Structure
```
api/
  gemini.js  # Serverless function that proxies Gemini API calls
              # Accepts POST with user answers, returns city match
              # Keeps GEMINI_API_KEY in Vercel env variables
```

### Testing AI Integration Locally
- Use `vercel dev` to test serverless functions locally
- Mock Gemini responses during development to avoid hitting rate limits
- Add console logging for API call counts (track daily 1500 limit)

## Critical Implementation Details

### Questions Data Structure
```javascript
// questions.js - 20 questions across 8 categories
// Categories: Climate (3), Lifestyle (3), Work (2), Food (2), 
//             Culture (3), Recreation (3), Family (2), Transportation (2)
// 
// CRITICAL: Questions must be indirect "riddles" that reveal preferences through
// scenarios WITHOUT stating what they measure. Never include location names or
// directly describe the answer (e.g., don't say "public transit" in a transit question)
//
// Good: "You're running late. You grab your..." (car keys vs metro card)
// Bad: "How do you feel about public transit?" or "Do you want to live in NYC?"
export const questions = [
  {
    id: 1,
    category: 'Lifestyle',
    text: 'It\'s 11 PM on a Tuesday. Where do you want to be?',
    type: 'binary', // or 'multiChoice'
    options: {
      left: 'In bed with a book (quiet life)',
      right: 'Out grabbing late-night food (vibrant nightlife)'
    }
  },
  // ... 19 more questions
];
```

### Gemini Prompt Engineering
- **System context:** "You are a relocation expert. Based on user preferences, recommend ONE specific city/country with reasoning."
- **Input format:** Send structured JSON of all 20 answers with question context
- **Output format:** Request JSON response with `{ city: string, country: string, explanation: string }`
- **Token optimization:** Keep prompts concise to maximize free tier usage
- **Error handling (MVP):** Simple try/catch with user-friendly message, no retry logic needed

### Google Maps Background Logic
```javascript
// Rotate through random cities after each question
const cities = ['Tokyo', 'Paris', 'NYC', 'Sydney', /* ... */];
const randomCity = cities[Math.floor(Math.random() * cities.length)];
// Update map center after each swipe animation completes
```

## Common Pitfalls & Gotchas

1. **Framer Motion 8-direction swipes:** Requires custom gesture detection logic (not built-in). Calculate angle from drag delta: `Math.atan2(dy, dx)` to map to 8 directions.

2. **localStorage quota:** Modern browsers limit ~5-10MB. Our 20 answers are tiny, but clear on game restart.

3. **Gemini API key security:** NEVER commit to Git. Always use Vercel environment variables + serverless function proxy.

4. **Google Maps API quotas:** Free tier is ~28,000 loads/month. Don't reload map unnecessarily—only on question transitions.

5. **Mobile-first swipe UX:** Test touch gestures on mobile; ensure swipe threshold is comfortable (not too sensitive/insensitive).

## Files to Create (Implementation Checklist)

### Essential Files
- `src/questions.js` - **ALREADY CREATED** - 20 scenario-based "riddle" questions (8 categories)
  - Questions reveal preferences through scenarios, never directly stating what they measure
  - Example: "You just got your paycheck. After rent, you have..." (reveals cost-of-living tolerance)
- `src/components/BinaryCard.jsx` - **COMPLETED** - Binary swipe card with Framer Motion, stacked effect, arrows
- `src/components/MultiChoiceCard.jsx` - **COMPLETED** - 8-direction swipe card matching BinaryCard design
- `src/components/QuestionIllustration.jsx` - **COMPLETED** - Renders custom SVG illustrations for each question
- `src/components/MapBackground.jsx` - **COMPLETED** - Google Maps integration
- `src/App.jsx` - **COMPLETED** - Game state machine (questions → AI call → results)
- `api/gemini.js` - **COMPLETED** - Vercel serverless function for Gemini API proxy
- `vercel.json` - **COMPLETED** - Deployment configuration
- `tailwind.config.js` - **COMPLETED** - Custom Zillow blue theme
- `src/assets/illustrations/` - **COMPLETED** - 20 custom SVG illustrations from ManyPixels Gallery

### Configuration
- Environment variables in Vercel: `GEMINI_API_KEY`, `GOOGLE_MAPS_API_KEY`
- `.gitignore` - Ensure `.env.local` is ignored

## Additional Context
- **Developer experience level:** Intermediate React knowledge, familiar with Tailwind
- **Design documents:** See `README.md` for game concept, `DECISIONS.md` for all tech stack rationale
- **Future expansion:** Phase 2 neighborhood matching game (not yet scoped)
- **Question distribution:** 20 total questions across 8 categories:
  - Climate & Environment (3): Temperature, seasons, natural disasters
  - Lifestyle & Pace (3): Urban density, nightlife, walkability
  - Work & Economy (2): Industry, cost of living
  - Food & Dining (2): Cuisine diversity, dining frequency
  - Culture & Values (3): Political climate, spirituality, arts scene
  - Recreation & Hobbies (3): Outdoor activities, sports, entertainment
  - Family & Social (2): School quality, proximity to loved ones
  - Transportation (2): Flying comfort, public transit needs

## When Making Changes
- **Lovable integration:** AI-generated UI from Lovable pushes directly to main—refactor to Tailwind conventions
- Reference `DECISIONS.md` before choosing alternative libraries/approaches
- Maintain zero-cost constraint—verify free tier limits before adding services
- Keep game flow simple—this is an MVP focused on core matching experience
- Write mobile-responsive code (Tailwind mobile-first classes)
- Test in Codespaces environment before pushing (Vercel auto-deploys on every commit)
- **Follow SDLC with Conventional Commits:** Use semantic commit messages (feat:, fix:, docs:, style:, refactor:, test:, chore:)
- **Commit often:** Make small, atomic commits after each logical change to maintain clear project history
